(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json",".html",".svg",".jade",".less"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';

        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';

        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }

        var n = loadNodeModulesSync(x, y);
        if (n) return n;

        throw new Error("Cannot find module '" + x + "'");

        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }

            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }

        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }

            return loadAsFileSync(x + '/index');
        }

        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }

            var m = loadAsFileSync(x);
            if (m) return m;
        }

        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');

            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }

            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);

    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;

    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }

        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;

        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };

        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/test/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var test = require(\"tape\")\nvar html = require(\"unpack-html\")\n\nvar simpleTemplate = require(\"./templates/simple\")\nvar nestedTemplate = require(\"./templates/nested\")\nvar Schema = require(\"../schema\")\nvar property = require(\"../property\")\n\ntest(\"schema is a function\", function (assert) {\n    assert.equal(typeof Schema, \"function\")\n    assert.equal(typeof Schema({}), \"function\")\n    assert.end()\n})\n\ntest(\"can populate data onto schema\", function (assert) {\n    var schema = Schema({\n        \"img\": \"src\"\n        , \"h1\": \"text\"\n        , \"span\": \"text\"\n    })\n\n    var elements = html(simpleTemplate)\n    schema(elements, {\n        \"img\": \"http://google.com/\"\n        , \"h1\": \"two\"\n        , \"span\": \"three\"\n    })\n\n    assert.equal(elements.img.src, \"http://google.com/\")\n    assert.equal(elements.h1.textContent, \"two\")\n    assert.equal(elements.span.textContent, \"three\")\n    assert.end()\n})\n\ntest(\"can populate nested data onto schema\", function (assert) {\n    var schema = Schema({\n        message: \"text\"\n        , author: {\n            name: \"text\"\n            , imageUri: \"src\"\n        }\n    })\n\n    var elements = html(nestedTemplate)\n    schema(elements, {\n        message: \"hello world\"\n        , author: {\n            name: \"Jake\"\n            , imageUri: \"http://google.com/foobar\"\n        }\n    })\n\n    assert.equal(elements.message.textContent, \"hello world\")\n    assert.equal(elements.author.name.textContent, \"Jake\")\n    assert.equal(elements.author.imageUri.src, \"http://google.com/foobar\")\n    assert.end()\n})\n\ntest(\"can do comma seperated\", function (assert) {\n    var schema = Schema({\n        author: {\n            imageUri: \"src, title\"\n        }\n    })\n\n    var elements = html(nestedTemplate)\n    schema(elements, {\n        author: {\n            imageUri: \"http://google.com/\"\n        }\n    })\n\n    assert.equal(elements.author.imageUri.src, \"http://google.com/\")\n    assert.equal(elements.author.imageUri.title, \"http://google.com/\")\n    assert.end()\n})\n\ntest(\"can do arrays\", function (assert) {\n    var schema = Schema({\n        author: {\n            imageUri: [\n                function (value, elem) {\n                    elem.src = \"http://google.com/\" + value\n                }\n                , property(\"textContent\", \"name\")\n            ]\n        }\n    })\n\n    var elements = html(nestedTemplate)\n    schema(elements, {\n        author: {\n            imageUri: \"foobar\"\n        }\n    })\n\n    assert.equal(elements.author.imageUri.src, \"http://google.com/foobar\")\n    assert.equal(elements.author.name.textContent, \"foobar\")\n    assert.end()\n})\n\n//@ sourceURL=/test/schema.js"
));

require.define("/node_modules/tape/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/package.json"
));

require.define("/node_modules/tape/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var createDefaultStream = require('./lib/default_stream');\nvar Render = require('./lib/render');\nvar Test = require('./lib/test');\n\nexports = module.exports = createHarness();\nexports.createHarness = createHarness;\nexports.Test = Test;\n\nvar canEmitExit = typeof process !== 'undefined' && process\n    && typeof process.on === 'function'\n;\nvar canExit = typeof process !== 'undefined' && process\n    && typeof process.exit === 'function'\n;\nvar onexit = (function () {\n    var stack = [];\n    if (canEmitExit) process.on('exit', function (code) {\n        for (var i = 0; i < stack.length; i++) stack[i](code);\n    });\n    return function (cb) { stack.push(cb) };\n})();\n\nfunction createHarness (conf_) {\n    var pending = [];\n    var running = false;\n    var count = 0;\n    \n    var began = false;\n    var only = false;\n    var closed = false;\n    var out = new Render();\n    \n    var test = function (name, conf, cb) {\n        count++;\n        var t = new Test(name, conf, cb);\n        if (!conf || typeof conf !== 'object') conf = conf_ || {};\n        \n        if (conf.exit !== false) {\n            onexit(function (code) {\n                t._exit();\n                if (!closed) {\n                    closed = true\n                    out.close();\n                }\n                if (!code && !t._ok && (!only || name === only)) {\n                    process.exit(1);\n                }\n            });\n        }\n        \n        process.nextTick(function () {\n            if (!out.piped) out.pipe(createDefaultStream());\n            if (!began) out.begin();\n            began = true;\n            \n            var run = function () {\n                running = true;\n                out.push(t);\n                t.run();\n            };\n            \n            if (only && name !== only) {\n                count--;\n                return;\n            }\n\n            if (running || pending.length) {\n                pending.push(run);\n            }\n            else run();\n        });\n        \n        t.on('test', function sub (st) {\n            count++;\n            st.on('test', sub);\n            st.on('end', onend);\n        });\n        \n        t.on('end', onend);\n        \n        return t;\n        \n        function onend () {\n            count--;\n            if (this._progeny.length) {\n                var unshifts = this._progeny.map(function (st) {\n                    return function () {\n                        running = true;\n                        out.push(st);\n                        st.run();\n                    };\n                });\n                pending.unshift.apply(pending, unshifts);\n            }\n            \n            process.nextTick(function () {\n                running = false;\n                if (pending.length) return pending.shift()();\n                if (count === 0 && !closed) {\n                    closed = true\n                    out.close();\n                }\n                if (conf.exit !== false && canExit && !t._ok) {\n                    process.exit(1);\n                }\n            });\n        }\n    };\n    \n    test.only = function (name) {\n        if (only) {\n            throw new Error(\"there can only be one only test\");\n        }\n        \n        only = name;\n        \n        return test.apply(null, arguments);\n    };\n    \n    test.stream = out;\n    return test;\n}\n\n// vim: set softtabstop=4 shiftwidth=4:\n\n//@ sourceURL=/node_modules/tape/index.js"
));

require.define("/node_modules/tape/lib/default_stream.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\n\nmodule.exports = function () {\n    var out = new Stream;\n    out.writable = true;\n    var buffered = '';\n    \n    out.write = function (buf) {\n        var s = buffered + String(buf);\n        var lines = s.split('\\n');\n        for (var i = 0; i < lines.length - 1; i++) {\n            console.log(lines[i]);\n        }\n        buffered = lines[i];\n    };\n    \n    out.destroy = function () {\n        out.writable = false;\n        out.emit('close');\n    };\n    \n    out.end = function (msg) {\n        if (msg !== undefined) out.write(msg);\n        if (buffered) console.log(buffered);\n        out.writable = false;\n        out.emit('close');\n    };\n    \n    return out;\n};\n\n//@ sourceURL=/node_modules/tape/lib/default_stream.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: colors ? stylizeWithColor : stylizeNoColor\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nvar colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\nvar styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + colors[style][0] + 'm' + str +\n           '\\u001b[' + colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    return String(value.inspect(recurseTimes));\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object_keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object_getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!visibleKeys.hasOwnProperty(key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/tape/lib/render.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\n\nmodule.exports = Render;\n\nfunction Render () {\n    Stream.call(this);\n    this.readable = true;\n    this.count = 0;\n    this.fail = 0;\n    this.pass = 0;\n}\n\nRender.prototype = new Stream;\n\nRender.prototype.pipe = function () {\n    this.piped = true;\n    return Stream.prototype.pipe.apply(this, arguments);\n};\n\nRender.prototype.begin = function () {\n    this.emit('data', 'TAP version 13\\n');\n};\n\nRender.prototype.push = function (t) {\n    var self = this;\n    this.emit('data', '# ' + t.name + '\\n');\n    \n    t.on('result', function (res) {\n        if (typeof res === 'string') {\n            self.emit('data', '# ' + res + '\\n');\n            return;\n        }\n\n        self.emit('data', encodeResult(res, self.count + 1));\n        self.count ++;\n        \n        if (res.ok) self.pass ++\n        else self.fail ++\n    });\n};\n\nRender.prototype.close = function () {\n    this.emit('data', '\\n1..' + this.count + '\\n');\n    this.emit('data', '# tests ' + this.count + '\\n');\n    this.emit('data', '# pass  ' + this.pass + '\\n');\n    if (this.fail) {\n        this.emit('data', '# fail  ' + this.fail + '\\n');\n    }\n    else {\n        this.emit('data', '\\n# ok\\n');\n    }\n    \n    this.emit('end');\n};\n\nfunction encodeResult (res, count) {\n    var output = '';\n    output += (res.ok ? 'ok ' : 'not ok ') + count;\n    output += res.name ? ' ' + res.name.replace(/\\s+/g, ' ') : '';\n    \n    if (res.skip) output += ' # SKIP';\n    else if (res.todo) output += ' # TODO';\n    \n    output += '\\n';\n    \n    if (!res.ok) {\n        var outer = '  ';\n        var inner = outer + '  ';\n        output += outer + '---\\n';\n        output += inner + 'operator: ' + res.operator + '\\n';\n        \n        var ex = json.stringify(res.expected) || '';\n        var ac = json.stringify(res.actual) || '';\n        \n        if (Math.max(ex.length, ac.length) > 65) {\n            output += inner + 'expected:\\n' + inner + '  ' + ex + '\\n';\n            output += inner + 'actual:\\n' + inner + '  ' + ac + '\\n';\n        }\n        else {\n            output += inner + 'expected: ' + ex + '\\n';\n            output += inner + 'actual:   ' + ac + '\\n';\n        }\n        if (res.at) {\n            output += inner + 'at: ' + res.at + '\\n';\n        }\n        if (res.operator === 'error' && res.actual && res.actual.stack) {\n            var lines = String(res.actual.stack).split('\\n');\n            output += inner + 'stack:\\n';\n            output += inner + '  ' + lines[0] + '\\n';\n            for (var i = 1; i < lines.length; i++) {\n                output += inner + lines[i] + '\\n';\n            }\n        }\n        \n        output += outer + '...\\n';\n    }\n    \n    return output;\n}\n\n//@ sourceURL=/node_modules/tape/lib/render.js"
));

require.define("/node_modules/tape/node_modules/jsonify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/package.json"
));

require.define("/node_modules/tape/node_modules/jsonify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/index.js"
));

require.define("/node_modules/tape/node_modules/jsonify/lib/parse.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/lib/parse.js"
));

require.define("/node_modules/tape/node_modules/jsonify/lib/stringify.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/lib/stringify.js"
));

require.define("/node_modules/tape/lib/test.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter;\nvar deepEqual = require('deep-equal');\nvar defined = require('defined');\nvar path = require('path');\n\nmodule.exports = Test;\n\nTest.prototype = new EventEmitter;\n\nfunction Test (name_, opts_, cb_) {\n    var name = '(anonymous)';\n    var opts = {};\n    var cb;\n    \n    for (var i = 0; i < arguments.length; i++) {\n        switch (typeof arguments[i]) {\n            case 'string':\n                name = arguments[i];\n                break;\n            case 'object':\n                opts = arguments[i] || opts;\n                break;\n            case 'function':\n                cb = arguments[i];\n        }\n    }\n    \n    EventEmitter.call(this);\n    \n    this.name = name || '(anonymous)';\n    this.assertCount = 0;\n    this._skip = opts.skip || false;\n    this._plan = undefined;\n    this._cb = cb;\n    this._progeny = [];\n    this._ok = true;\n}\n\nTest.prototype.run = function () {\n    if (this._skip) {\n        return this.end();\n    }\n    try {\n        this._cb(this);\n    }\n    catch (err) {\n        this.error(err);\n        this.end();\n    }\n};\n\nTest.prototype.test = function (name, opts, cb) {\n    var t = new Test(name, opts, cb);\n    this._progeny.push(t);\n    this.emit('test', t);\n};\n\nTest.prototype.comment = function (msg) {\n    this.emit('result', msg.trim().replace(/^#\\s*/, ''));\n};\n\nTest.prototype.plan = function (n) {\n    this._plan = n;\n    this.emit('plan', n);\n};\n\nTest.prototype.end = function () {\n    if (!this.ended) this.emit('end');\n    if (this._plan !== undefined &&\n        !this._planError && this.assertCount !== this._plan) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected : this._plan,\n            actual : this.assertCount\n        });\n    }\n    this.ended = true;\n};\n\nTest.prototype._exit = function () {\n    if (this._plan !== undefined &&\n        !this._planError && this.assertCount !== this._plan) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected : this._plan,\n            actual : this.assertCount\n        });\n    }\n    else if (!this.ended) {\n        this.fail('test exited without ending');\n    }\n    \n};\n\nTest.prototype._assert = function assert (ok, opts) {\n    var self = this;\n    var extra = opts.extra || {};\n    \n    var res = {\n        id : self.assertCount ++,\n        ok : Boolean(ok),\n        skip : defined(extra.skip, opts.skip),\n        name : defined(extra.message, opts.message, '(unnamed assert)'),\n        operator : defined(extra.operator, opts.operator),\n        actual : defined(extra.actual, opts.actual),\n        expected : defined(extra.expected, opts.expected)\n    };\n    this._ok = Boolean(this._ok && ok);\n    \n    if (!ok) {\n        res.error = defined(extra.error, opts.error, new Error(res.name));\n    }\n    \n    var e = new Error('exception');\n    var err = (e.stack || '').split('\\n');\n    var dir = path.dirname(__dirname) + '/';\n    \n    for (var i = 0; i < err.length; i++) {\n        var m = /^\\s*\\bat\\s+(.+)/.exec(err[i]);\n        if (!m) continue;\n        \n        var s = m[1].split(/\\s+/);\n        var filem = /(\\/[^:\\s]+:(\\d+)(?::(\\d+))?)/.exec(s[1]);\n        if (!filem) continue;\n        \n        if (filem[1].slice(0, dir.length) === dir) continue;\n        \n        res.functionName = s[0];\n        res.file = filem[1];\n        res.line = Number(filem[2]);\n        if (filem[3]) res.column = filem[3];\n        \n        res.at = m[1];\n        break;\n    }\n    \n    self.emit('result', res);\n    \n    if (self._plan === self.assertCount) {\n        process.nextTick(function () {\n            if (!self.ended) self.end();\n        });\n    }\n    \n    if (!self._planError && self.assertCount > self._plan) {\n        self._planError = true;\n        self.fail('plan != count', {\n            expected : self._plan,\n            actual : self.assertCount\n        });\n    }\n};\n\nTest.prototype.fail = function (msg, extra) {\n    this._assert(false, {\n        message : msg,\n        operator : 'fail',\n        extra : extra\n    });\n};\n\nTest.prototype.pass = function (msg, extra) {\n    this._assert(true, {\n        message : msg,\n        operator : 'pass',\n        extra : extra\n    });\n};\n\nTest.prototype.skip = function (msg, extra) {\n    this._assert(true, {\n        message : msg,\n        operator : 'skip',\n        skip : true,\n        extra : extra\n    });\n};\n\nTest.prototype.ok\n= Test.prototype['true']\n= Test.prototype.assert\n= function (value, msg, extra) {\n    this._assert(value, {\n        message : msg,\n        operator : 'ok',\n        expected : true,\n        actual : value,\n        extra : extra\n    });\n};\n\nTest.prototype.notOk\n= Test.prototype['false']\n= Test.prototype.notok\n= function (value, msg, extra) {\n    this._assert(!value, {\n        message : msg,\n        operator : 'notOk',\n        expected : false,\n        actual : value,\n        extra : extra\n    });\n};\n\nTest.prototype.error\n= Test.prototype.ifError\n= Test.prototype.ifErr\n= Test.prototype.iferror\n= function (err, msg, extra) {\n    this._assert(!err, {\n        message : defined(msg, String(err)),\n        operator : 'error',\n        actual : err,\n        extra : extra\n    });\n};\n\nTest.prototype.equal\n= Test.prototype.equals\n= Test.prototype.isEqual\n= Test.prototype.is\n= Test.prototype.strictEqual\n= Test.prototype.strictEquals\n= function (a, b, msg, extra) {\n    this._assert(a === b, {\n        message : defined(msg, 'should be equal'),\n        operator : 'equal',\n        actual : a,\n        expected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.notEqual\n= Test.prototype.notEquals\n= Test.prototype.notStrictEqual\n= Test.prototype.notStrictEquals\n= Test.prototype.isNotEqual\n= Test.prototype.isNot\n= Test.prototype.not\n= Test.prototype.doesNotEqual\n= Test.prototype.isInequal\n= function (a, b, msg, extra) {\n    this._assert(a !== b, {\n        message : defined(msg, 'should not be equal'),\n        operator : 'notEqual',\n        actual : a,\n        notExpected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.deepEqual\n= Test.prototype.deepEquals\n= Test.prototype.isEquivalent\n= Test.prototype.looseEqual\n= Test.prototype.looseEquals\n= Test.prototype.same\n= function (a, b, msg, extra) {\n    this._assert(deepEqual(a, b), {\n        message : defined(msg, 'should be equivalent'),\n        operator : 'deepEqual',\n        actual : a,\n        expected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.notDeepEqual\n= Test.prototype.notEquivalent\n= Test.prototype.notDeeply\n= Test.prototype.notSame\n= Test.prototype.isNotDeepEqual\n= Test.prototype.isNotDeeply\n= Test.prototype.isNotEquivalent\n= Test.prototype.isInequivalent\n= function (a, b, msg, extra) {\n    this._assert(!deepEqual(a, b), {\n        message : defined(msg, 'should not be equivalent'),\n        operator : 'notDeepEqual',\n        actual : a,\n        notExpected : b,\n        extra : extra\n    });\n};\n\nTest.prototype['throws'] = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n    var caught = undefined;\n    try {\n        fn();\n    }\n    catch (err) {\n        caught = { error : err };\n        var message = err.message;\n        delete err.message;\n        err.message = message;\n    }\n\n    var passed = caught;\n\n    if (expected instanceof RegExp) {\n        passed = expected.test(caught && caught.error);\n        expected = String(expected);\n    }\n\n    this._assert(passed, {\n        message : defined(msg, 'should throw'),\n        operator : 'throws',\n        actual : caught && caught.error,\n        expected : expected,\n        error: !passed && caught && caught.error,\n        extra : extra\n    });\n};\n\nTest.prototype.doesNotThrow = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n    var caught = undefined;\n    try {\n        fn();\n    }\n    catch (err) {\n        caught = { error : err };\n    }\n    this._assert(!caught, {\n        message : defined(msg, 'should throw'),\n        operator : 'throws',\n        actual : caught && caught.error,\n        expected : expected,\n        error : caught && caught.error,\n        extra : extra\n    });\n};\n\n// vim: set softtabstop=4 shiftwidth=4:\n\n//@ sourceURL=/node_modules/tape/lib/test.js"
));

require.define("/node_modules/tape/node_modules/deep-equal/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/deep-equal/package.json"
));

require.define("/node_modules/tape/node_modules/deep-equal/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var pSlice = Array.prototype.slice;\nvar Object_keys = typeof Object.keys === 'function'\n    ? Object.keys\n    : function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    }\n;\n\nvar deepEqual = module.exports = function (actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b);\n  }\n  try {\n    var ka = Object_keys(a),\n        kb = Object_keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n//@ sourceURL=/node_modules/tape/node_modules/deep-equal/index.js"
));

require.define("/node_modules/tape/node_modules/defined/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/defined/package.json"
));

require.define("/node_modules/tape/node_modules/defined/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = function () {\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] !== undefined) return arguments[i];\n    }\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/defined/index.js"
));

require.define("/node_modules/unpack-html/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-html/package.json"
));

require.define("/node_modules/unpack-html/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var unpack = require(\"unpack-element\")\n    , domify = require(\"domify\")\n\nmodule.exports = html\n\nfunction html(source) {\n    return unpack(domify(source.trim())[0])\n}\n\n//@ sourceURL=/node_modules/unpack-html/index.js"
));

require.define("/node_modules/unpack-html/node_modules/unpack-element/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-html/node_modules/unpack-element/package.json"
));

require.define("/node_modules/unpack-html/node_modules/unpack-element/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var walk = require(\"dom-walk\")\nvar dotty = require(\"dotty\")\nvar DataSet = require(\"data-set\")\n\nmodule.exports = unpack\n\nfunction unpack(elem, mapping) {\n    var struct = {}\n\n    walk([elem], findChildren)\n\n    if (!struct.root) {\n        struct.root = elem\n    }\n\n    if (mapping) {\n        Object.keys(mapping).forEach(findElement)\n    }\n\n    return struct\n\n    function findChildren(node) {\n        var ds = DataSet(node)\n        var marker = ds.marker\n\n        if (marker) {\n            dotty.put(struct, marker, node)\n        }\n    }\n\n    function findElement(key) {\n        var className = mapping[key]\n        var children = elem.getElementsByClassName(className)\n        struct[key] = children[0]\n    }\n}\n\n//@ sourceURL=/node_modules/unpack-html/node_modules/unpack-element/index.js"
));

require.define("/node_modules/dom-walk/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/dom-walk/package.json"
));

require.define("/node_modules/dom-walk/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var slice = Array.prototype.slice\n\nmodule.exports = iterativelyWalk\n\nfunction iterativelyWalk(nodes, cb) {\n    nodes = slice.call(nodes)\n\n    while(nodes.length) {\n        var node = nodes.shift(),\n            ret = cb(node)\n\n        if (ret) {\n            return ret\n        }\n\n        if (node.childNodes.length) {\n            nodes = slice.call(node.childNodes).concat(nodes)\n        }\n    }\n}\n//@ sourceURL=/node_modules/dom-walk/index.js"
));

require.define("/node_modules/dotty/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/index.js\"}\n//@ sourceURL=/node_modules/dotty/package.json"
));

require.define("/node_modules/dotty/lib/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//@ sourceURL=/node_modules/dotty/lib/index.js"
));

require.define("/node_modules/data-set/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/data-set/package.json"
));

require.define("/node_modules/data-set/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Weakmap = require(\"weakmap\")\n\n    , datasetMap = Weakmap()\n\nmodule.exports = DataSet\n\nfunction DataSet(elem) {\n    var hash = datasetMap.get(elem)\n\n    if (!hash) {\n        hash = createHash(elem)\n        datasetMap.set(elem, hash)\n    }\n\n    return hash\n}\n\nfunction createHash(elem) {\n    var attributes = elem.attributes\n        , hash = {}\n\n    if (attributes === null) {\n        return hash\n    }\n\n    for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i]\n\n        if (attr.name.substr(0,5) !== \"data-\") {\n            continue\n        }\n\n        hash[attr.name.substr(5)] = attr.value\n    }\n\n    return hash\n}\n\n//@ sourceURL=/node_modules/data-set/index.js"
));

require.define("/node_modules/data-set/node_modules/weakmap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"weakmap.js\"}\n//@ sourceURL=/node_modules/data-set/node_modules/weakmap/package.json"
));

require.define("/node_modules/data-set/node_modules/weakmap/weakmap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* (The MIT License)\r\n *\r\n * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included with all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\r\nvoid function(global, undefined_, undefined){\r\n  var getProps = Object.getOwnPropertyNames,\r\n      defProp  = Object.defineProperty,\r\n      toSource = Function.prototype.toString,\r\n      create   = Object.create,\r\n      hasOwn   = Object.prototype.hasOwnProperty,\r\n      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\r\n\r\n  function define(object, key, value){\r\n    if (typeof key === 'function') {\r\n      value = key;\r\n      key = nameOf(value).replace(/_$/, '');\r\n    }\r\n    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n  }\r\n\r\n  function nameOf(func){\r\n    return typeof func !== 'function'\r\n          ? '' : 'name' in func\r\n          ? func.name : toSource.call(func).match(funcName)[1];\r\n  }\r\n\r\n  // ############\r\n  // ### Data ###\r\n  // ############\r\n\r\n  var Data = (function(){\r\n    var dataDesc = { value: { writable: true, value: undefined } },\r\n        datalock = 'return function(k){if(k===s)return l}',\r\n        uids     = create(null),\r\n\r\n        createUID = function(){\r\n          var key = Math.random().toString(36).slice(2);\r\n          return key in uids ? createUID() : uids[key] = key;\r\n        },\r\n\r\n        globalID = createUID(),\r\n\r\n        storage = function(obj){\r\n          if (hasOwn.call(obj, globalID))\r\n            return obj[globalID];\r\n\r\n          if (!Object.isExtensible(obj))\r\n            throw new TypeError(\"Object must be extensible\");\r\n\r\n          var store = create(null);\r\n          defProp(obj, globalID, { value: store });\r\n          return store;\r\n        };\r\n\r\n    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n    define(Object, function getOwnPropertyNames(obj){\r\n      var props = getProps(obj);\r\n      if (hasOwn.call(obj, globalID))\r\n        props.splice(props.indexOf(globalID), 1);\r\n      return props;\r\n    });\r\n\r\n    function Data(){\r\n      var puid = createUID(),\r\n          secret = {};\r\n\r\n      this.unlock = function(obj){\r\n        var store = storage(obj);\r\n        if (hasOwn.call(store, puid))\r\n          return store[puid](secret);\r\n\r\n        var data = create(null, dataDesc);\r\n        defProp(store, puid, {\r\n          value: new Function('s', 'l', datalock)(secret, data)\r\n        });\r\n        return data;\r\n      }\r\n    }\r\n\r\n    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\r\n    return Data;\r\n  }());\r\n\r\n\r\n  var WM = (function(data){\r\n    var validate = function(key){\r\n      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n        throw new TypeError(\"Invalid WeakMap key\");\r\n    }\r\n\r\n    var wrap = function(collection, value){\r\n      var store = data.unlock(collection);\r\n      if (store.value)\r\n        throw new TypeError(\"Object is already a WeakMap\");\r\n      store.value = value;\r\n    }\r\n\r\n    var unwrap = function(collection){\r\n      var storage = data.unlock(collection).value;\r\n      if (!storage)\r\n        throw new TypeError(\"WeakMap is not generic\");\r\n      return storage;\r\n    }\r\n\r\n    var initialize = function(weakmap, iterable){\r\n      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n        iterable.forEach(function(item, i){\r\n          if (item instanceof Array && item.length === 2)\r\n            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function WeakMap(iterable){\r\n      if (this === global || this == null || this === WeakMap.prototype)\r\n        return new WeakMap(iterable);\r\n\r\n      wrap(this, new Data);\r\n      initialize(this, iterable);\r\n    }\r\n\r\n    function get(key){\r\n      validate(key);\r\n      var value = unwrap(this).get(key);\r\n      return value === undefined_ ? undefined : value;\r\n    }\r\n\r\n    function set(key, value){\r\n      validate(key);\r\n      // store a token for explicit undefined so that \"has\" works correctly\r\n      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n    }\r\n\r\n    function has(key){\r\n      validate(key);\r\n      return unwrap(this).get(key) !== undefined;\r\n    }\r\n\r\n    function delete_(key){\r\n      validate(key);\r\n      var data = unwrap(this),\r\n          had = data.get(key) !== undefined;\r\n      data.set(key, undefined);\r\n      return had;\r\n    }\r\n\r\n    function toString(){\r\n      unwrap(this);\r\n      return '[object WeakMap]';\r\n    }\r\n\r\n    try {\r\n      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n    } catch (e) {\r\n      var del = delete_;\r\n    }\r\n\r\n    var src = (''+Object).split('Object');\r\n    var stringifier = function toString(){\r\n      return src[0] + nameOf(this) + src[1];\r\n    };\r\n\r\n    define(stringifier, stringifier);\r\n\r\n    var prep = { __proto__: [] } instanceof Array\r\n      ? function(f){ f.__proto__ = stringifier }\r\n      : function(f){ define(f, stringifier) };\r\n\r\n    prep(WeakMap);\r\n\r\n    [toString, get, set, has, del].forEach(function(method){\r\n      define(WeakMap.prototype, method);\r\n      prep(method);\r\n    });\r\n\r\n    return WeakMap;\r\n  }(new Data));\r\n\r\n  var defaultCreator = Object.create\r\n    ? function(){ return Object.create(null) }\r\n    : function(){ return {} };\r\n\r\n  function createStorage(creator){\r\n    var weakmap = new WM;\r\n    creator || (creator = defaultCreator);\r\n\r\n    function storage(object, value){\r\n      if (value || arguments.length === 2) {\r\n        weakmap.set(object, value);\r\n      } else {\r\n        value = weakmap.get(object);\r\n        if (value === undefined) {\r\n          value = creator(object);\r\n          weakmap.set(object, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    return storage;\r\n  }\r\n\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = WM;\r\n  } else if (typeof exports !== 'undefined') {\r\n    exports.WeakMap = WM;\r\n  } else if (!('WeakMap' in global)) {\r\n    global.WeakMap = WM;\r\n  }\r\n\r\n  WM.createStorage = createStorage;\r\n  if (global.WeakMap)\r\n    global.WeakMap.createStorage = createStorage;\r\n}((0, eval)('this'));\r\n\n//@ sourceURL=/node_modules/data-set/node_modules/weakmap/weakmap.js"
));

require.define("/node_modules/unpack-html/node_modules/domify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/unpack-html/node_modules/domify/package.json"
));

require.define("/node_modules/unpack-html/node_modules/domify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n/**\n * Expose `parse`.\n */\n\nmodule.exports = parse;\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  option: [1, '<select multiple=\"multiple\">', '</select>'],\n  optgroup: [1, '<select multiple=\"multiple\">', '</select>'],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  thead: [1, '<table>', '</table>'],\n  tbody: [1, '<table>', '</table>'],\n  tfoot: [1, '<table>', '</table>'],\n  colgroup: [1, '<table>', '</table>'],\n  caption: [1, '<table>', '</table>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  th: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  _default: [0, '', '']\n};\n\n/**\n * Parse `html` and return the children.\n *\n * @param {String} html\n * @return {Array}\n * @api private\n */\n\nfunction parse(html) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n  \n  // tag name\n  var m = /<([\\w:]+)/.exec(html);\n  if (!m) throw new Error('No elements were generated.');\n  var tag = m[1];\n  \n  // body support\n  if (tag == 'body') {\n    var el = document.createElement('html');\n    el.innerHTML = html;\n    return [el.removeChild(el.lastChild)];\n  }\n  \n  // wrap map\n  var wrap = map[tag] || map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = document.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  return orphan(el.children);\n}\n\n/**\n * Orphan `els` and return an array.\n *\n * @param {NodeList} els\n * @return {Array}\n * @api private\n */\n\nfunction orphan(els) {\n  var ret = [];\n\n  while (els.length) {\n    ret.push(els[0].parentNode.removeChild(els[0]));\n  }\n\n  return ret;\n}\n\n//@ sourceURL=/node_modules/unpack-html/node_modules/domify/index.js"
));

require.define("/test/templates/simple.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div>\\n    <h1 data-marker=\\\"h1\\\"></h1>\\n    <span data-marker=\\\"span\\\"></span>\\n    <img data-marker=\\\"img\\\"></img>\\n</div>\\n\"\n//@ sourceURL=/test/templates/simple.html"
));

require.define("/test/templates/nested.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div>\\n    <div class=\\\"person\\\">\\n        <div data-marker=\\\"author.name\\\"></div>\\n        <img data-marker=\\\"author.imageUri\\\"></img>\\n    </div>\\n    <div class=\\\"text\\\" data-marker=\\\"message\\\"></div>\\n</div>\\n\"\n//@ sourceURL=/test/templates/nested.html"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"schema.js\"}\n//@ sourceURL=/package.json"
));

require.define("/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var fold = require(\"reducers/fold\")\n\nvar Render = require(\"./render\")\n\nmodule.exports = Schema\n\nfunction Schema(mapping) {\n    var render = Render(mapping)\n\n    return schema\n\n    function schema(elements, input) {\n        fold(input, function (data) {\n            render(data, elements)\n        })\n\n        return elements\n    }\n}\n\n//@ sourceURL=/schema.js"
));

require.define("/node_modules/reducers/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/package.json"
));

require.define("/node_modules/reducers/fold.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar isError = require(\"reducible/is-error\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\nvar hub = require(\"./hub\")\n\nfunction Promise() {\n  this.delivered = false\n  this.next = void(0)\n  this.initial = void(0)\n}\nreduce.define(Promise, function reducePromise(promise, next, initial) {\n  if (promise.delivered) return reduce(promise.value, next, initial)\n  promise.next = next\n  promise.initial = initial\n})\n\nfunction deliver(promise, value) {\n  promise.delivered = true\n  promise.value = value\n  if (promise.next) reduce(value, promise.next, promise.initial)\n}\n\n\nfunction fold(source, next, initial) {\n  /**\n  Fold is just like `reduce` with a difference that `next` reducer / folder\n  function it takes has it's parameters reversed. One always needs `value`,\n  but not always accumulated one. To avoid conflict with array `reduce` we\n  have a `fold`.\n  **/\n  var promise = new Promise()\n  reduce(source, function fold(value, state) {\n    // If source is `end`-ed deliver accumulated `state`.\n    // If is source has an error, deliver that.\n    if (isError(value)) {\n      deliver(promise, value)\n      throw value\n    }\n    if (value === end) return deliver(promise, state)\n\n    // Accumulate new `state`\n    state = next(value, state)\n    // If already reduced, then deliver.\n    if (isReduced(state)) deliver(promise, state.value)\n\n    return state\n  }, initial)\n\n  return promise.delivered ? promise.value : hub(promise)\n}\n\nmodule.exports = fold\n\n//@ sourceURL=/node_modules/reducers/fold.js"
));

require.define("/node_modules/reducible/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./reducible.js\"}\n//@ sourceURL=/node_modules/reducible/package.json"
));

require.define("/node_modules/reducible/reduce.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar globalScope = typeof window !== \"undefined\" ?\n  window : typeof global !== \"undefined\" ?\n  global : {}\n\nif (globalScope[\"__gozala/reducibe__is__defined\"]) {\n  console.warn(\"There are two copies of reducible/reduce. This will most \" +\n    \"likely cause problems. You should npm dedup\")\n} else {\n  globalScope[\"__gozala/reducibe__is__defined\"] = true\n}\n\nvar method = require(\"method\")\n\nvar isReduced = require(\"./is-reduced\")\nvar isError = require(\"./is-error\")\nvar end = require(\"./end\")\n\nvar reduce = method(\"reduce\")\n\n// Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial)\n}\n\n// Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial))\n}\n\n// Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial\n  var index = 0\n  var count = indexed.length\n  while (index < count) {\n    var value = indexed[index]\n    state = next(value, state)\n    index = index + 1\n    if (value === end) return end\n    if (isError(value)) return state\n    if (isReduced(state)) return state.value\n  }\n  next(end, state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\nreduce.define(void(0), reduce.empty)\nreduce.define(null, reduce.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\nreduce.define(Array, reduce.indexed)\n\nfunction Arguments() { return arguments }\nArguments.prototype = Arguments()\nreduce.define(Arguments, reduce.indexed)\n\n// All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\nreduce.define(reduce.singular)\n\n// Errors just yield that error.\nreduce.define(Error, function(error, next) { next(error) })\nmodule.exports = reduce\n\n//@ sourceURL=/node_modules/reducible/reduce.js"
));

require.define("/node_modules/reducible/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/reducible/node_modules/method/package.json"
));

require.define("/node_modules/reducible/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\n\n// Shortcut for `Object.prototype.toString` for faster access.\nvar typefy = Object.prototype.toString\n\n// Map to for jumping from typeof(value) to associated type prefix used\n// as a hash in the map of builtin implementations.\nvar types = { \"function\": \"Object\", \"object\": \"Object\" }\n\n// Array is used to save method implementations for the host objects in order\n// to avoid extending them with non-primitive values that could cause leaks.\nvar host = []\n// Hash map is used to save method implementations for builtin types in order\n// to avoid extending their prototypes. This also allows to share method\n// implementations for types across diff contexts / frames / compartments.\nvar builtin = {}\n\nfunction Primitive() {}\nfunction ObjectType() {}\nObjectType.prototype = new Primitive()\nfunction ErrorType() {}\nErrorType.prototype = new ObjectType()\n\nvar Default = builtin.Default = Primitive.prototype\nvar Null = builtin.Null = new Primitive()\nvar Void = builtin.Void = new Primitive()\nbuiltin.String = new Primitive()\nbuiltin.Number = new Primitive()\nbuiltin.Boolean = new Primitive()\n\nbuiltin.Object = ObjectType.prototype\nbuiltin.Error = ErrorType.prototype\n\nbuiltin.EvalError = new ErrorType()\nbuiltin.InternalError = new ErrorType()\nbuiltin.RangeError = new ErrorType()\nbuiltin.ReferenceError = new ErrorType()\nbuiltin.StopIteration = new ErrorType()\nbuiltin.SyntaxError = new ErrorType()\nbuiltin.TypeError = new ErrorType()\nbuiltin.URIError = new ErrorType()\n\n\nfunction Method(hint) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method:\n\n      method(object, ...rest) => object[method](...rest)\n\n  Optionally hint string may be provided that will be used in generated names\n  to ease debugging.\n\n  ## Example\n\n      var foo = Method()\n\n      // Implementation for any types\n      foo.define(function(value, arg1, arg2) {\n        // ...\n      })\n\n      // Implementation for a specific type\n      foo.define(BarType, function(bar, arg1, arg2) {\n        // ...\n      })\n  **/\n\n  // Create an internal unique name if `hint` is provided it is used to\n  // prefix name to ease debugging.\n  var name = (hint || \"\") + \"#\" + Math.random().toString(32).substr(2)\n\n  function dispatch(value) {\n    // Method dispatches on type of the first argument.\n    // If first argument is `null` or `void` associated implementation is\n    // looked up in the `builtin` hash where implementations for built-ins\n    // are stored.\n    var type = null\n    var method = value === null ? Null[name] :\n                 value === void(0) ? Void[name] :\n                 // Otherwise attempt to use method with a generated private\n                 // `name` that is supposedly in the prototype chain of the\n                 // `target`.\n                 value[name] ||\n                 // Otherwise assume it's one of the built-in type instances,\n                 // in which case implementation is stored in a `builtin` hash.\n                 // Attempt to find a implementation for the given built-in\n                 // via constructor name and method name.\n                 ((type = builtin[(value.constructor || \"\").name]) &&\n                  type[name]) ||\n                 // Otherwise assume it's a host object. For host objects\n                 // actual method implementations are stored in the `host`\n                 // array and only index for the implementation is stored\n                 // in the host object's prototype chain. This avoids memory\n                 // leaks that otherwise could happen when saving JS objects\n                 // on host object.\n                 host[value[\"!\" + name]] ||\n                 // Otherwise attempt to lookup implementation for builtins by\n                 // a type of the value. This basically makes sure that all\n                 // non primitive values will delegate to an `Object`.\n                 ((type = builtin[types[typeof(value)]]) && type[name])\n\n\n    // If method implementation for the type is still not found then\n    // just fallback for default implementation.\n    method = method || Default[name]\n\n\n    // If implementation is still not found (which also means there is no\n    // default) just throw an error with a descriptive message.\n    if (!method) throw TypeError(\"Type does not implements method: \" + name)\n\n    // If implementation was found then just delegate.\n    return method.apply(method, arguments)\n  }\n\n  // Make `toString` of the dispatch return a private name, this enables\n  // method definition without sugar:\n  //\n  //    var method = Method()\n  //    object[method] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Create method shortcuts form functions.\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n// Define `implement` and `define` polymorphic methods to allow definitions\n// and implementations through them.\nvar implement = Method(\"implement\")\nvar define = Method(\"define\")\n\n\nfunction _implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  return defineProperty(object, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n}\n\nfunction _define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n\n  // Attempt to guess a type via `Object.prototype.toString.call` hack.\n  var type = Type && typefy.call(Type.prototype)\n\n  // If only two arguments are passed then `Type` is actually an implementation\n  // for a default type.\n  if (!lambda) Default[method] = Type\n  // If `Type` is `null` or `void` store implementation accordingly.\n  else if (Type === null) Null[method] = lambda\n  else if (Type === void(0)) Void[method] = lambda\n  // If `type` hack indicates built-in type and type has a name us it to\n  // store a implementation into associated hash. If hash for this type does\n  // not exists yet create one.\n  else if (type !== \"[object Object]\" && Type.name) {\n    var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType())\n    Bulitin[method] = lambda\n  }\n  // If `type` hack indicates an object, that may be either object or any\n  // JS defined \"Class\". If name of the constructor is `Object`, assume it's\n  // built-in `Object` and store implementation accordingly.\n  else if (Type.name === \"Object\")\n    builtin.Object[method] = lambda\n  // Host objects are pain!!! Every browser does some crazy stuff for them\n  // So far all browser seem to not implement `call` method for host object\n  // constructors. If that is a case here, assume it's a host object and\n  // store implementation in a `host` array and store `index` in the array\n  // in a `Type.prototype` itself. This avoids memory leaks that could be\n  // caused by storing JS objects on a host objects.\n  else if (Type.call === void(0)) {\n    var index = host.indexOf(lambda)\n    if (index < 0) index = host.push(lambda) - 1\n    // Prefix private name with `!` so it can be dispatched from the method\n    // without type checks.\n    implement(\"!\" + method, Type.prototype, index)\n  }\n  // If Got that far `Type` is user defined JS `Class`. Define private name\n  // as hidden property on it's prototype.\n  else\n    implement(method, Type.prototype, lambda)\n}\n\n// And provided implementations for a polymorphic equivalents.\n_define(define, _define)\n_define(implement, _implement)\n\n// Define exports on `Method` as it's only thing being exported.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.method = Method\nMethod.builtin = builtin\nMethod.host = host\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/reducible/node_modules/method/core.js"
));

require.define("/node_modules/reducible/is-reduced.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduced = require(\"./reduced\")\n\nfunction isReduced(value) {\n  return value && value.is === reduced\n}\n\nmodule.exports = isReduced\n\n//@ sourceURL=/node_modules/reducible/is-reduced.js"
));

require.define("/node_modules/reducible/reduced.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n\n// Exported function can be used for boxing values. This boxing indicates\n// that consumer of sequence has finished consuming it, there for new values\n// should not be no longer pushed.\nfunction reduced(value) {\n  /**\n  Boxes given value and indicates to a source that it's already reduced and\n  no new values should be supplied\n  **/\n  return { value: value, is: reduced }\n}\n\nmodule.exports = reduced\n\n//@ sourceURL=/node_modules/reducible/reduced.js"
));

require.define("/node_modules/reducible/is-error.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar stringifier = Object.prototype.toString\n\nfunction isError(value) {\n  return stringifier.call(value) === \"[object Error]\"\n}\n\nmodule.exports = isError\n\n//@ sourceURL=/node_modules/reducible/is-error.js"
));

require.define("/node_modules/reducible/end.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nmodule.exports = String(\"End of the collection\")\n\n//@ sourceURL=/node_modules/reducible/end.js"
));

require.define("/node_modules/reducers/hub.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reduced = require(\"reducible/reduced\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\n\nvar isArray = Array.isArray\n\nfunction Hub(source) {\n  this[input] = source\n  this[consumers] = []\n}\n\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({ next: next, state: initial })\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub)\n})\n\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length\n    var index = 0\n    while (index < count) {\n      var consumer = consumers[index]\n      consumer.next(end, consumer.state)\n      index = index + 1\n    }\n    consumers.splice(0, count)\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length\n  var index = 0\n  while (index < count) {\n    var consumer = consumers[index]\n    var state = consumer.next(value, consumer.state)\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (isReduced(state)) {\n      consumers.splice(index, 1)\n      consumer.next(end, state.value)\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1\n    } else {\n      consumer.state = state\n      index = index + 1\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input]\n  var reducers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers)\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value)\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source\n      return reduced()\n    }\n  })\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null\n  if (source === void(0)) return void(0)\n  return new Hub(source)\n}\nhub.isOpen = isOpen\nhub.type = Hub\n\nmodule.exports = hub\n\n//@ sourceURL=/node_modules/reducers/hub.js"
));

require.define("/render.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = Render\n\nvar Hash = require(\"./hash\")\nvar Multiple = require(\"./multiple\")\nvar Property = require(\"./property\")\n\nfunction Render(mapping) {\n    if (Array.isArray(mapping)) {\n        return Multiple(mapping)\n    } else if (typeof mapping === \"object\" && mapping !== null) {\n        return Hash(mapping)\n    } else if (typeof mapping === \"string\") {\n        return Property(mapping)\n    } else if (typeof mapping === \"function\") {\n        return mapping\n    } else {\n        throw new Error(\"populate/render: mapping should be something\")\n    }\n}\n\n//@ sourceURL=/render.js"
));

require.define("/hash.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var inspect = require(\"util\").inspect\n\nvar Render = require(\"./render\")\n\nmodule.exports = Hash\n\nfunction Hash(mapping) {\n    if (typeof mapping !== \"object\" || mapping === null) {\n        throw new Error(\"populate/hash: mapping should be an object\")\n    }\n\n    var definition = Object.keys(mapping).\n        reduce(function (acc, key) {\n            acc[key] = Render(mapping[key])\n            return acc\n        }, {})\n\n    return render\n\n    function render(data, elements) {\n        Object.keys(data).forEach(function (key) {\n            var value = data[key]\n            var elem = elements[key]\n            var render = definition[key]\n\n            if (!render) {\n                throw new Error(\"populate/hash: There is no \" +\n                    \"rendering definition for property \" + key +\n                    \" of data \" + inspect(data))\n            }\n\n            render(value, elem, elements)\n        })\n    }\n}\n\n//@ sourceURL=/hash.js"
));

require.define("/multiple.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Render = require(\"./render\")\n\nmodule.exports = Multiple\n\nfunction Multiple(arr) {\n    if (!Array.isArray(arr)) {\n        throw new Error(\"populate/multiple: arr should be an array\")\n    }\n\n    arr = arr.map(Render)\n\n    return render\n\n    function render(value, elem, elements) {\n        arr.forEach(function (f) {\n            f(value, elem, elements)\n        })\n    }\n}\n\n//@ sourceURL=/multiple.js"
));

require.define("/property.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var get = require(\"dotty\").get\n\nmodule.exports = Property\n\nfunction Property(property, name) {\n    if (typeof property !== \"string\") {\n        throw new Error(\"populate/property: property should be a string\")\n    }\n\n    var properties = property.\n        split(\",\").\n        map(function (prop) {\n            return prop === \"text\" ? \"textContent\" : prop\n        }).\n        map(function (prop) {\n            return prop.trim()\n        })\n\n    return render\n\n    function render(value, elem, elements) {\n        if (name) {\n            elem = get(elements, name)\n        }\n\n        elem && properties.forEach(function (prop) {\n            elem[prop] = value\n        })\n    }\n}\n\n//@ sourceURL=/property.js"
));

require.define("/test/bind.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var test = require(\"tape\")\nvar html = require(\"unpack-html\")\n\nvar simpleTemplate = require(\"./templates/simple-bind\")\nvar nestedTemplate = require(\"./templates/nested-bind\")\nvar commaTemplate = require(\"./templates/comma-bind\")\nvar multiTemplate = require(\"./templates/multi-bind\")\nvar bind = require(\"../bind\")\n\ntest(\"simple bind\", function (assert) {\n    var elements = html(simpleTemplate)\n    elements = bind(elements, {\n        \"img\": \"http://google.com/\"\n        , \"h1\": \"two\"\n        , \"span\": \"three\"\n    })\n\n    assert.equal(elements.img.src, \"http://google.com/\")\n    assert.equal(elements.h1.textContent, \"two\")\n    assert.equal(elements.span.textContent, \"three\")\n    assert.end()\n})\n\ntest(\"nested bind\", function (assert) {\n    var elements = html(nestedTemplate)\n    elements = bind(elements, {\n        message: \"hello world\"\n        , author: {\n            name: \"Jake\"\n            , imageUri: \"http://google.com/foobar\"\n        }\n    })\n\n    assert.equal(elements.message.textContent, \"hello world\")\n    assert.equal(elements.author.name.textContent, \"Jake\")\n    assert.equal(elements.author.imageUri.src, \"http://google.com/foobar\")\n    assert.end()\n})\n\ntest(\"comma seperated bind\", function (assert) {\n    var elements = html(commaTemplate)\n    elements = bind(elements, {\n        author: {\n            imageUri: \"http://google.com/\"\n        }\n    })\n\n    assert.equal(elements.author.imageUri.src, \"http://google.com/\")\n    assert.equal(elements.author.imageUri.title, \"http://google.com/\")\n    assert.end()\n})\n\ntest(\"can bind same data to multiple places\", function (assert) {\n    var elements = html(multiTemplate)\n    bind(elements, {\n        foo: {\n            message: \"hello\"\n        }\n    })\n\n    assert.equal(elements.first.src, \"hello\")\n    assert.equal(elements.second.textContent, \"hello\")\n    assert.end()\n})\n\ntest(\"can overwrite schema programmatically\", function (assert) {\n    var elements = html(nestedTemplate)\n    elements = bind(elements, {\n        message: \"hello world\"\n        , author: {\n            name: \"Jake\"\n            , imageUri: \"http://google.com/foobar\"\n        }\n    }, {\n        message: function (value, elem, elements) {\n            // console.log(\"called?\", elements.author.name.foo, value)\n            elements.author.name.foo = value\n        }\n        , author: {\n            name: \"bar\"\n        }\n    })\n\n    assert.equal(elements.message.textContent, \"hello world\")\n    assert.equal(elements.author.name.textContent, \"Jake\")\n    assert.equal(elements.author.name.foo, \"hello world\")\n    assert.equal(elements.author.name.bar, \"Jake\")\n    assert.equal(elements.author.imageUri.src, \"http://google.com/foobar\")\n    assert.end()\n})\n\n//@ sourceURL=/test/bind.js"
));

require.define("/test/templates/simple-bind.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div>\\n    <h1 data-bind=\\\"h1\\\"></h1>\\n    <span data-bind=\\\"span\\\"></span>\\n    <img data-bind=\\\"src:img\\\"></img>\\n</div>\\n\"\n//@ sourceURL=/test/templates/simple-bind.html"
));

require.define("/test/templates/nested-bind.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div>\\n    <div class=\\\"person\\\">\\n        <div data-bind=\\\"author.name\\\"></div>\\n        <img data-bind=\\\"src:author.imageUri\\\"></img>\\n    </div>\\n    <div class=\\\"text\\\" data-bind=\\\"message\\\"></div>\\n</div>\\n\"\n//@ sourceURL=/test/templates/nested-bind.html"
));

require.define("/test/templates/comma-bind.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div data-bind=\\\"src:author.imageUri, title:author.imageUri\\\"></div>\\n\"\n//@ sourceURL=/test/templates/comma-bind.html"
));

require.define("/test/templates/multi-bind.html",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = \"<div data-marker=\\\"first\\\" data-bind=\\\"src:foo.message\\\">\\n    <div data-marker=\\\"second\\\" data-bind=\\\"foo.message\\\"></div>\\n</div>\\n\"\n//@ sourceURL=/test/templates/multi-bind.html"
));

require.define("/bind.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var walk = require(\"dom-walk\")\nvar DataSet = require(\"data-set\")\nvar inspect = require(\"util\").inspect\nvar dotty = require(\"dotty\")\nvar DeepMerge = require(\"deep-merge\")\nvar extend = require(\"xtend\")\nvar put = dotty.put\nvar get = dotty.get\n\nvar Schema = require(\"./schema\")\nvar property = require(\"./property\")\n\nvar deepmerge = DeepMerge(function (a, b) {\n    return [].concat(a, b)\n})\n\nmodule.exports = bind\n\nfunction bind(elements, input, mapping) {\n    if (!elements.root) {\n        elements = { root: elements }\n    }\n\n    var results = parse(elements.root)\n    var elements = extend({}, elements, results.elements)\n    mapping = deepmerge(results.mapping, mapping || {})\n    Schema(mapping)(elements, input)\n    return elements\n}\n\nfunction parse(rootElem) {\n    var elements = {}\n    var mapping = {}\n\n    walk([rootElem], function (elem) {\n        var ds = DataSet(elem)\n\n        if (ds.bind) {\n            var binding = ds.bind\n            var bindings = binding.split(\",\").map(trim)\n\n            bindings.forEach(function (binding) {\n                applyBinding(elem, binding)\n            })\n        }\n    })\n\n    return { mapping: mapping, elements: elements }\n\n    function applyBinding(elem, binding) {\n        var parts = binding.split(\":\").map(trim)\n        if (parts.length === 1) {\n            parts = [\"textContent\", parts[0]]\n        }\n\n        var prop = parts[0]\n        var path = parts[1]\n        var existingElem = get(elements, path)\n        var hasDifferentElem = existingElem && existingElem !== elem\n        /* If this path already has an element then it means\n            that there are two elements which want a single\n            piece of data to be rendered there.\n\n            What we do is generate a unique element path by\n            postfixing ~ to it\n\n        */\n        var elemPath = hasDifferentElem ? path + \"~\" : path\n        put(elements, elemPath, elem)\n\n        /* There is already an element at this path. Which\n            means we need to change the mapping to be\n\n            {\n                path: [\n                    whatever, is, already, here\n                    , property(prop, elemPath.split('.')[last])\n                ]\n            }\n\n        */\n        if (hasDifferentElem) {\n            var elemPathPieces = elemPath.split(\".\")\n            var lastPiece = elemPathPieces[elemPathPieces.length - 1]\n            prop = property(prop, lastPiece)\n        }\n\n        prop = addProp(path, prop)\n        put(mapping, path, prop)\n    }\n\n    function addProp(path, prop) {\n        var existingProp = get(mapping, path)\n        if (existingProp) {\n            if (!Array.isArray(existingProp)) {\n                existingProp = [existingProp]\n            }\n\n            prop = existingProp.concat(prop)\n        }\n\n        return prop\n    }\n}\n\nfunction trim(str) {\n    return str.trim()\n}\n\n//@ sourceURL=/bind.js"
));

require.define("/node_modules/deep-merge/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/deep-merge/package.json"
));

require.define("/node_modules/deep-merge/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var extend = require(\"xtend\")\n\nmodule.exports = DeepMerge\n\nfunction DeepMerge(merger) {\n    return deepmerge\n\n    function deepmerge(target, source, key) {\n        if (Array.isArray(source) && Array.isArray(target)) {\n            return merger(target, source, key)\n        } else if (isObject(source) && isObject(target)) {\n            var result = extend({}, target)\n            Object.keys(source).forEach(merge)\n            return result\n        } else {\n            return merger(target, source, key)\n        }\n\n        function merge(key) {\n            var sourceValue = source[key]\n            var targetValue = target[key]\n\n            if (!(key in target)) {\n                result[key] = sourceValue\n            } else {\n                result[key] = deepmerge(targetValue, sourceValue, key)\n            }\n        }\n    }\n}\n\nfunction isObject(x) {\n    return typeof x === \"object\" && x !== null\n}\n\n//@ sourceURL=/node_modules/deep-merge/index.js"
));

require.define("/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/xtend/package.json"
));

require.define("/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/xtend/index.js"
));

require.define("/node_modules/browserify-server/other.js",Function(['require','module','exports','__dirname','__filename','process','global'],"process.env.NODE_ENV = 'undefined'\n\n//@ sourceURL=/node_modules/browserify-server/other.js"
));
require("/node_modules/browserify-server/other.js");

require.define("/test/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"require(\"./schema\")\nrequire(\"./bind\")\n\n//@ sourceURL=/test/index.js"
));
require("/test/index.js");
})();
